<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Style-Type" content="text/css" />
</head>
  <body>

<!DOCTYPE html>
<meta charset="utf-8">
<style>
.legendThreshold {
    font-size: 12px;
    font-family: sans-serif;
}

    .d3-tip {
    line-height: 1.5;
    font-weight: 400;
    font-family:"Times New Roman", Times, serif;
    padding: 6px;
    background: rgba(0, 0, 0, 0.6);
    color: #FFA500;
    border-radius: 1px;
    pointer-events: none;
    }

    .d3-tip:after {
      box-sizing: border-box;
      display: inline;
      font-size: 8px;
      width: 100%;
      line-height: 1.5;
      color: rgba(0, 0, 0, 0.6);
      position: absolute;
      pointer-events: none;

    }

    .d3-tip.n:after {
      content: "\25BC";
      margin: -1px 0 0 0;
      top: 100%;
      left: 0;
      text-align: center;
    }

    .d3-tip.e:after {
      content: "\25C0";
      margin: -4px 0 0 0;
      top: 50%;
      left: -8px;
    }

    .d3-tip.s:after {
      content: "\25B2";
      margin: 0 0 1px 0;
      top: -8px;
      left: 0;
      text-align: center;
    }

    .d3-tip.w:after {
      content: "\25B6";
      margin: -4px 0 0 -1px;
      top: 50%;
      left: 100%;
    }

    .names {
    fill: none;
    stroke: #fff;
    stroke-linejoin: round;
    }

    .details{
      color:white;
    }



</style>
<body>
  <div>
      <div style="margin:100px;">
          <p>
Happiness is a state of well-being that encompasses living a good life. Happiness is subjective
and can change over time or due to certain conditions as well. When you ask an individual
about his happiness at a particular time his answer will depend on the recent happenings in life,
with that being said it may happen that his answer will change after a given period of time. For
most of the countries, the happiness index has only increased over time from 2010 to 2018 for
countries like Iceland, Finland Which were in the top happy to begin with in 2010. Malawi and
Syria have a maximum deficit in happiness from 2010 to 2018 and these countries were part of
bottom happy countries.
          </p>
          <h2>Top 10 Countries:</h2>
          <div style="border:3px solid;">
          <svg id="topBottom"></svg>
          <hr>
          <h2>Bottom 10 Countries:</h2>
          <svg id="Bottom"></svg>

          </div>

      </div>
  </div>

<script src="http://d3js.org/d3.v4.min.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3-legend/2.24.0/d3-legend.js"></script>
<script>
d3.functor = function functor(v) {
  return typeof v === "function" ? v : function() {
    return v;
  };
};

d3.tip = function() {

  var direction = d3_tip_direction,
      offset    = d3_tip_offset,
      html      = d3_tip_html,
      node      = initNode(),
      svg       = null,
      point     = null,
      target    = null

  function tip(vis) {
    svg = getSVGNode(vis)
    point = svg.createSVGPoint()
    document.body.appendChild(node)
  }

  tip.show = function() {
    var args = Array.prototype.slice.call(arguments)
    if(args[args.length - 1] instanceof SVGElement) target = args.pop()

    var content = html.apply(this, args),
        poffset = offset.apply(this, args),
        dir     = direction.apply(this, args),
        nodel   = getNodeEl(),
        i       = directions.length,
        coords,
        scrollTop  = document.documentElement.scrollTop || document.body.scrollTop,
        scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft

    nodel.html(content)
      .style('position', 'absolute')
      .style('opacity', 1)
      .style('pointer-events', 'all')

    while(i--) nodel.classed(directions[i], false)
    coords = direction_callbacks[dir].apply(this)
    nodel.classed(dir, true)
      .style('top', (coords.top +  poffset[0]) + scrollTop + 'px')
      .style('left', (coords.left + poffset[1]) + scrollLeft + 'px')

    return tip
  }

  tip.hide = function() {
    var nodel = getNodeEl()
    nodel
      .style('opacity', 0)
      .style('pointer-events', 'none')
    return tip
  }

  tip.attr = function(n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return getNodeEl().attr(n)
    } else {
      var args =  Array.prototype.slice.call(arguments)
      d3.selection.prototype.attr.apply(getNodeEl(), args)
    }

    return tip
  }
  tip.style = function(n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return getNodeEl().style(n)
    } else {
      var args = Array.prototype.slice.call(arguments);
      if (args.length === 1) {
        var styles = args[0];
        Object.keys(styles).forEach(function(key) {
          return d3.selection.prototype.style.apply(getNodeEl(), [key, styles[key]]);
        });
      }
    }

    return tip
  }


  tip.direction = function(v) {
    if (!arguments.length) return direction
    direction = v == null ? v : d3.functor(v)

    return tip
  }


  tip.offset = function(v) {
    if (!arguments.length) return offset
    offset = v == null ? v : d3.functor(v)

    return tip
  }


  tip.html = function(v) {
    if (!arguments.length) return html
    html = v == null ? v : d3.functor(v)

    return tip
  }

  tip.destroy = function() {
    if(node) {
      getNodeEl().remove();
      node = null;
    }
    return tip;
  }

  function d3_tip_direction() { return 'n' }
  function d3_tip_offset() { return [0, 0] }
  function d3_tip_html() { return ' ' }

  var direction_callbacks = {
    n:  direction_n,
    s:  direction_s,
    e:  direction_e,
    w:  direction_w,
    nw: direction_nw,
    ne: direction_ne,
    sw: direction_sw,
    se: direction_se
  };

  var directions = Object.keys(direction_callbacks);

  function direction_n() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.n.y - node.offsetHeight,
      left: bbox.n.x - node.offsetWidth / 2
    }
  }

  function direction_s() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.s.y,
      left: bbox.s.x - node.offsetWidth / 2
    }
  }

  function direction_e() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.e.y - node.offsetHeight / 2,
      left: bbox.e.x
    }
  }

  function direction_w() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.w.y - node.offsetHeight / 2,
      left: bbox.w.x - node.offsetWidth
    }
  }

  function direction_nw() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.nw.y - node.offsetHeight,
      left: bbox.nw.x - node.offsetWidth
    }
  }

  function direction_ne() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.ne.y - node.offsetHeight,
      left: bbox.ne.x
    }
  }

  function direction_sw() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.sw.y,
      left: bbox.sw.x - node.offsetWidth
    }
  }

  function direction_se() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.se.y,
      left: bbox.e.x
    }
  }

  function initNode() {
    var node = d3.select(document.createElement('div'))
    node
      .style('position', 'absolute')
      .style('top', 0)
      .style('opacity', 0)
      .style('pointer-events', 'none')
      .style('box-sizing', 'border-box')

    return node.node()
  }

  function getSVGNode(el) {
    el = el.node()
    if(el.tagName.toLowerCase() === 'svg')
      return el

    return el.ownerSVGElement
  }

  function getNodeEl() {
    if(node === null) {
      node = initNode();
      // re-add node to DOM
      document.body.appendChild(node);
    };
    return d3.select(node);
  }

  function getScreenBBox() {
    var targetel   = target || d3.event.target;

    while ('undefined' === typeof targetel.getScreenCTM && 'undefined' === targetel.parentNode) {
        targetel = targetel.parentNode;
    }

    var bbox       = {},
        matrix     = targetel.getScreenCTM(),
        tbbox      = targetel.getBBox(),
        width      = tbbox.width,
        height     = tbbox.height,
        x          = tbbox.x,
        y          = tbbox.y

    point.x = x
    point.y = y
    bbox.nw = point.matrixTransform(matrix)
    point.x += width
    bbox.ne = point.matrixTransform(matrix)
    point.y += height
    bbox.se = point.matrixTransform(matrix)
    point.x -= width
    bbox.sw = point.matrixTransform(matrix)
    point.y -= height / 2
    bbox.w  = point.matrixTransform(matrix)
    point.x += width
    bbox.e = point.matrixTransform(matrix)
    point.x -= width / 2
    point.y -= height / 2
    bbox.n = point.matrixTransform(matrix)
    point.y += height
    bbox.s = point.matrixTransform(matrix)

    return bbox
  }

  return tip
};
</script>
<script>
let store = {}

var format = d3.format(",");


var xtip = d3.tip()
            .attr('class', 'd3-tip')
            .offset([-10, 0])
            .html(function(d) {
              return "<strong>Country: </strong><span class='details'>" + d.properties.name + "<br></span>" + "<strong>Happiness Index: </strong><span class='details'>"+ format(d.CHANGE) +"</span>";
            })


var margin = {top: 0, right: 0, bottom: 0, left: 0},
            width = 960 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

var dcolor = d3.scaleThreshold()
    .domain([-0.4,-0.3,-0.2,-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6])
    .range(["rgb(255,69,0)", "rgb(255,127,80)", " rgb(255,140,0)", "rgb(255,215,0)", "rgb(255,255,255)", "rgb(66,146,198)","rgb(33,113,181)","rgb(8,81,156)","rgb(8,48,107)","rgb(3,19,43)"]);

var bcolor = d3.scaleThreshold()
    .domain([-0.4,-0.3,-0.2,-0.1,0,0.1,0.2,0.3,0.4,0.5,0.6])
    .range(["rgb(255,69,0)", "rgb(255,127,80)", " rgb(255,140,0)", "rgb(255,215,0)", "rgb(255,255,255)", "rgb(66,146,198)","rgb(33,113,181)","rgb(8,81,156)","rgb(8,48,107)","rgb(3,19,43)"]);

var path = d3.geoPath();

var svg = d3.select("body")
            .append("svg")
            .attr("width", width)
            .attr("height", height)
            .append('g')
            .attr('class', 'map');

var projection = d3.geoMercator()
                   .scale(130)
                  .translate( [width / 2, height / 1.5]);

var path = d3.geoPath().projection(projection);

svg.call(xtip);
svg.call(bot_tip);


function loadData()
{
  queue()
  .defer(d3.json, "countries.geo.json")
  .defer(d3.csv, "Q2_Change_Combined")
  .await(ready);
}

function getDonor(){
  let width = window.innerWidth;
  let height = window.innerHeight;
  let container = d3.select('#topBottom');
  container.attr("width", width).attr("height", height);
  return {width, height, container}
}
function Reciever_Map_Config(){
  let width = window.innerWidth;
  let height = window.innerHeight;
  let container = d3.select('#topBottom');
  container.attr("width", width).attr("height", height);
  return {width, height, container}
}


function ready(error,data,dataset)
{
  let donor_config = getDonor();
  donor_container_svg = donor_config.container;
  display(donor_container_svg,data,dataset,dcolor);
  let recv_config = Reciever_Map_Config();
  rec_container_svg = recv_config.container;
  display(rec_container_svg,data,dataset,bcolor);
}


loadData();

function extend(obj, src) {
    var objArray = []

    for (var key in obj) {
         var newobject1 = {}
         newobject1 = obj[key]
         objArray.push(newobject1)
        }

    for(var key in src)
    {
      var newobject2 = {}
      newobject2 = src[key];
      objArray.push(newobject2);
    }
  return objArray;
}

function display(container, data, dataset, rcv_clr_or_dnr_clr) {
  var countryiesById = {};


    // dataset.forEach(function(d) { countryiesById[d.Country] = +d["CHANGE"]; });
    // console.log(countryiesById)


    var topData = dataset.sort(function(a, b) {
            return d3.descending(+a.CHANGE, +b.CHANGE);
          }).slice(0,10)
    // topData.forEach(function(d) { countryiesById[d.Country] = +d["CHANGE"]; });
    // console.log(countryiesById)

    var bottomData = dataset.sort(function(a, b) {
                  return d3.ascending(+a.CHANGE, +b.CHANGE);
                }).slice(0,10)

    allData = extend(topData, bottomData);

    allData.forEach(function(d) { countryiesById[d.Country] = +d["CHANGE"] });
    data.features.forEach(function(d) { d["CHANGE"] = countryiesById[d.properties.name] });



  container.append("g")
      .attr("class", "countries")
      .selectAll("path")
      .data(data.features)
      .enter().append("path")
      .attr("d", path)
      .style("fill", function(d) {
        if (countryiesById[d.properties.name] == undefined)
        {
          return rcv_clr_or_dnr_clr (1);
        }
        else
        {
          return rcv_clr_or_dnr_clr(countryiesById[d.properties.name]);
        }})
      .style('stroke', 'white')
      .style('stroke-width', 1.5)
      .style("opacity",0.8)
        .style("stroke","white")
        .style('stroke-width', 0.3)
        .on('mouseover',function(d){
          xtip.show(d);

          d3.select(this)
            .style("opacity", 1)
            .style("stroke","white")
            .style("stroke-width",3);
        })
        .on('mouseout', function(d){
          xtip.hide(d);

          d3.select(this)
            .style("opacity", 0.8)
            .style("stroke","white")
            .style("stroke-width",0.3);
        });

  container.append("path")
      .datum(topojson.mesh(data.features, function(a, b) { return a.id !== b.id; }))
      .attr("class", "names")
      .attr("d", path);
}



</script>
</body>
</html>

  </body>
</html>
